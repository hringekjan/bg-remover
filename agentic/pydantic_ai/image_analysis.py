import json
import re
import time
from typing import Literal, Optional, List, Dict, Any, get_args

import boto3
from pydantic import BaseModel, Field, ValidationError

# --- Data Models ---

class ImageMetadata(BaseModel):
    """Simplified metadata for image routing, for now."""
    complexityScore: Optional[float] = None
    megapixels: Optional[float] = None
    fileSizeMB: Optional[float] = None

class ProcessingOptions(BaseModel):
    """Simplified processing options for routing, for now."""
    generateDescription: bool = True

class ProductCondition(str, Literal["new_with_tags", "like_new", "very_good", "good", "fair"]):
    """Enum for product conditions."""
    pass

class ProductDescription(BaseModel):
    """Structured product description generated by AI."""
    short: str = Field(..., description="A short, elegant name for the product.")
    long: str = Field(..., description="A 3-sentence marketing description.")
    category: str = Field(..., description="Product category (e.g., clothing, accessories).")
    colors: List[str] = Field(..., description="List of main colors.")
    condition: ProductCondition = Field(..., description="Product condition.")
    keywords: List[str] = Field(..., description="Relevant SEO keywords.")
    stylingTip: Optional[str] = Field(None, description="A styling tip for the product.")

class BilingualProductDescription(BaseModel):
    """Product description in English and Icelandic."""
    en: ProductDescription
    is_: ProductDescription = Field(..., alias="is") # Use alias for 'is' keyword

# --- Agent Class ---

class BedrockImageAnalyzer:
    """
    Agent for analyzing images to generate product descriptions and translating them
    using AWS Bedrock models.
    """
    def __init__(self,
                 vision_region: str = 'us-east-1',
                 translation_region: str = 'eu-west-1'):
        self.vision_client = boto3.client('bedrock-runtime', region_name=vision_region)
        self.translation_client = boto3.client('bedrock-runtime', region_name=translation_region)
        self.default_vision_model_id = 'us.mistral.pixtral-large-2502-v1:0'
        self.default_translation_model_id = 'openai.gpt-oss-120b-1:0'

    def _invoke_vision_model(self, model_id: str, prompt: str, base64_image: str) -> Dict[str, Any]:
        """Helper to invoke a vision model with image and text prompt."""
        request_body = {
            "max_tokens": 1000,
            "temperature": 0.7,
            "system": [{"text": "You are an expert fashion curator and copywriter for Hringekjan, a premium sustainable marketplace."}],
            "messages": [
                {
                    "role": "user",
                    "content": [
                        {
                            "type": "image",
                            "source": {
                                "type": "base64",
                                "media_type": "image/png", # Assuming PNG, adjust if needed
                                "data": base64_image
                            }
                        },
                        {
                            "type": "text",
                            "text": prompt
                        }
                    ]
                }
            ]
        }
        
        response = self.vision_client.invoke_model(
            modelId=model_id,
            contentType='application/json',
            accept='application/json',
            body=json.dumps(request_body)
        )
        return json.loads(response['body'].read().decode('utf-8'))

    def analyze_image_for_description(
        self,
        image_buffer_b64: str = Field(..., description="Base64 encoded input image buffer."),
        product_name: Optional[str] = Field(None, description="Optional name of the product for context."),
        metadata: Optional[ImageMetadata] = Field(None, description="Optional image metadata for dynamic model routing.")
    ) -> ProductDescription:
        """
        Analyzes an image to generate a structured product description.

        Args:
            image_buffer_b64: Base64 encoded string of the input image.
            product_name: Optional name of the product for additional context.
            metadata: Optional image metadata (e.g., size, complexity) for dynamic model routing.

        Returns:
            A ProductDescription object containing AI-generated product details.
        """
        # Simplified routing: always use the default model for now
        selected_model_id = self.default_vision_model_id
        print(f"Using vision model: {selected_model_id}")

        prompt = f"""Act as a high-end fashion copywriter for Hringekjan.is. 
Generate elegant, professional product metadata for a premium second-hand item.

Context:
{f'- Product Name: {product_name}' if product_name else ''}

Instructions:
1. Provide a specific 'Elegant Name' (e.g., 'Tailored Silk Blouse' instead of just 'Shirt').
2. Write a 3-sentence 'Marketing Description' that sounds timeless, sophisticated, and sustainable.
3. Identify the product category (clothing, accessories, etc.).
4. List main colors.
5. Provide a product condition assessment (choose from: new_with_tags, like_new, very_good, good, fair).
6. Suggest relevant SEO keywords.
7. Include a 'Styling Tip'.

Format your response as JSON with keys: short, long, category, colors, condition, keywords, stylingTip"""

        try:
            response_body = self._invoke_vision_model(
                selected_model_id,
                prompt,
                image_buffer_b64
            )

            analysis_text: str = response_body.get('output', {}).get('message', {}).get('content', [{}])[0].get('text', '')
            if not analysis_text:
                raise ValueError(f"No text content in response from {selected_model_id}")

            json_match = re.search(r'\{[\s\S]*\}', analysis_text)
            parsed_json = json.loads(json_match.group(0) if json_match else analysis_text)

            condition = parsed_json.get('condition')
            if condition not in get_args(ProductCondition): # type: ignore
                condition = 'very_good' # Default if invalid

            return ProductDescription(
                short=parsed_json.get('short', product_name or 'Product'),
                long=parsed_json.get('long', 'High-quality product processed and optimized for sale.'),
                category=parsed_json.get('category', 'General'),
                colors=parsed_json.get('colors') if isinstance(parsed_json.get('colors'), list) else (parsed_json.get('colors').split(',') if parsed_json.get('colors') else ['various']),
                condition=condition,
                keywords=parsed_json.get('keywords') if isinstance(parsed_json.get('keywords'), list) else (parsed_json.get('keywords').split(',') if parsed_json.get('keywords') else ['product']),
                stylingTip=parsed_json.get('stylingTip')
            )
        except Exception as e:
            print(f"Error analyzing image with model {selected_model_id}: {e}")
            # Fallback to intelligent analysis if LLM fails
            return self._intelligent_analysis_fallback(product_name)

    def _intelligent_analysis_fallback(self, product_name: Optional[str]) -> ProductDescription:
        """Provides a simplified fallback analysis based on product name."""
        print('Using intelligent analysis fallback for:', product_name)
        category = 'general'
        keywords: List[str] = ['product', 'item']
        default_colors: List[str] = ['black', 'white', 'gray']
        condition: ProductCondition = 'very_good' # type: ignore
        short_description = product_name or 'Product'
        long_description = 'High-quality product in excellent condition, ready for immediate use.'

        if product_name:
            name = product_name.lower()
            if 'dress' in name or 'gown' in name or 'skirt' in name:
                category = 'clothing'
                keywords = ['fashion', 'apparel', 'clothing', 'dress']
                default_colors = ['red', 'blue', 'black', 'white', 'navy', 'gray']
                long_description = 'Elegant and stylish clothing item, perfect for any occasion. High-quality fabric with excellent craftsmanship.'
            # ... (add more fallback logic as per original TS if needed, simplified for brevity)

        return ProductDescription(
            short=short_description,
            long=long_description,
            category=category,
            colors=default_colors,
            condition=condition,
            keywords=keywords
        )

    def translate_to_icelandic(
        self,
        description: ProductDescription = Field(..., description="Product description to translate.")
    ) -> ProductDescription:
        """
        Translates a ProductDescription object into Icelandic using an LLM.

        Args:
            description: The ProductDescription object to translate.

        Returns:
            A new ProductDescription object with translated fields.
        """
        try:
            prompt = f"""Translate this product description to Icelandic. Keep the same structure and format.

Short: {description.short}
Long: {description.long}
Category: {description.category or 'General'}
Colors: {', '.join(description.colors) if description.colors else ''}
Condition: {description.condition or ''}
Keywords: {', '.join(description.keywords) if description.keywords else ''}
Styling Tip: {description.stylingTip or ''}

Provide the response in the same JSON format with keys: short, long, category, colors, condition, keywords, stylingTip"""

            request_body = {
                "messages": [
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                "max_tokens": 1000,
                "temperature": 0.3
            }

            response = self.translation_client.invoke_model(
                modelId=self.default_translation_model_id,
                contentType='application/json',
                accept='application/json',
                body=json.dumps(request_body)
            )

            response_body = json.loads(response['body'].read().decode('utf-8'))
            translation_text = response_body.get('choices', [{}])[0].get('message', {}).get('content', '') or response_body.get('content', '')

            json_match = re.search(r'\{[\s\S]*\}', translation_text)
            if json_match:
                translation_text = json_match.group(0)
            
            translation_data = json.loads(translation_text)
            
            return ProductDescription(
                short=translation_data.get('short', description.short),
                long=translation_data.get('long', description.long),
                category=translation_data.get('category', description.category),
                colors=translation_data.get('colors') if isinstance(translation_data.get('colors'), list) else description.colors,
                condition=translation_data.get('condition', description.condition),
                keywords=translation_data.get('keywords') if isinstance(translation_data.get('keywords'), list) else description.keywords,
                stylingTip=translation_data.get('stylingTip', description.stylingTip)
            )
        except Exception as e:
            print(f"Translation failed, returning original: {e}")
            return description

    def generate_bilingual_description(
        self,
        image_buffer_b64: str = Field(..., description="Base64 encoded input image buffer."),
        product_name: Optional[str] = Field(None, description="Optional name of the product for context."),
        metadata: Optional[ImageMetadata] = Field(None, description="Optional image metadata for routing.")
    ) -> BilingualProductDescription:
        """
        Generates a bilingual (English and Icelandic) product description from an image.

        Args:
            image_buffer_b64: Base64 encoded string of the input image.
            product_name: Optional name of the product for additional context.
            metadata: Optional image metadata (e.g., size, complexity) for dynamic model routing.

        Returns:
            A BilingualProductDescription object.
        """
        english_description = self.analyze_image_for_description(image_buffer_b64, product_name, metadata)
        icelandic_description = self.translate_to_icelandic(english_description)

        return BilingualProductDescription(en=english_description, is_=icelandic_description)
